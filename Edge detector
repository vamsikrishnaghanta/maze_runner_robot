import numpy as np

# Assuming the angles from the horizontal axis in each image (in degrees)
theta1 = np.radians(45)  # Replace with actual angle in radians from camera 1
theta2 = np.radians(30)  # Replace with actual angle in radians from camera 2
theta3 = np.radians(60)  # Replace with actual angle in radians from camera 3

# Assuming the radius of the tube (distance from camera to the wire center)
radius = 1.0  # Replace with actual radius

# Positions of the cameras around the tube (in degrees)
camera_angles = [0, 120, 240]

# Convert angles to 3D coordinates
def calculate_3d_point(theta, camera_angle, radius):
    camera_angle_rad = np.radians(camera_angle)
    x = radius * np.cos(camera_angle_rad)
    y = radius * np.sin(camera_angle_rad)
    z = radius * np.tan(theta)
    return np.array([x, y, z])

# 3D coordinates of the wire points from each camera
points_3d = np.array([
    calculate_3d_point(theta1, camera_angles[0], radius),
    calculate_3d_point(theta2, camera_angles[1], radius),
    calculate_3d_point(theta3, camera_angles[2], radius)
])

# Calculate the centroid of the 3D points
centroid = np.mean(points_3d, axis=0)

# Subtract the centroid to center the points at the origin
centered_points = points_3d - centroid

# Perform Singular Value Decomposition (SVD) to find the normal of the plane
U, S, Vt = np.linalg.svd(centered_points)
normal_vector = Vt[-1]

# The z-axis in the 3D coordinate system
z_axis = np.array([0, 0, 1])

# Calculate the angle between the normal vector and the z-axis
dot_product = np.dot(normal_vector, z_axis)
angle = np.arccos(dot_product / np.linalg.norm(normal_vector))

# Convert the angle from radians to degrees
bend_angle = np.degrees(angle)

print(f"Bend angle of the wire with respect to the tube's center axis: {bend_angle:.2f} degrees")
